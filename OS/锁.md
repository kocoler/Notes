### 乐观锁

它总认为资源和数据不会被别人所修改
所以读取不会上锁
但是乐观锁在进行写入操作的时候会判断当前数据是否被修改过

不太适合多写场景

措施：
- 版本号
  写的时候对比 version 如果不一致则重新执行

- CAS
  当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做

### 悲观锁

它总认为最坏的情况可能会出现
它认为数据很可能会被其他人所修改
所以悲观锁在持有数据（读/写）的时候总会把资源 或者 数据 锁住

比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁

就是 **排他锁**

### 自旋锁

就是不断自旋，查看状态

除了内核态，用户态应该避免使用

这些是为了保证公平性的
- TicketLock
  拿票据

下面这俩都是本地变量自旋
不需要多处理器缓存同步

- CLHLock
  基于链表（隐式）
  自旋询问前一个节点是否释放

- MCSLock
  基于链表（显式）
  询问当前节点的状态
  这个状态由前一个节点更想你
