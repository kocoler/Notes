### 设计模式

经典的有 22 种

- 创建型模式
  - 工厂方法
    父类提供一个**创建对象的接口**以允许子类决定实例化对象的类型

  - 抽象工厂
    创建一系列相关的对象
    无需指定其具体类

  - 生成器
    分步骤创建复杂对象

  - 单例
    一个类只有一个实例
    提供一个访问该实例的全局节点

  - 原型
    复制已有对象，无需使代码依赖他们所属的类

- 结构型模式
  适配器模式能为被封装对象提供不同的接口，代理模式能为对象提供相同的接口，装饰模式则能为对象提供加强的接口。

  - 适配器模式（封装器模式）
    适配器模式是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。

    1. 适配器实现与其中一个现有对象兼容的接口。
    2. 现有对象可以使用该接口安全地调用适配器方法。
    3. 适配器方法被调用后将以另一个对象兼容的格式和顺序将请求传递给该对象。

  - 代理模式
    代理控制着对于原对象的访问，并允许在将请求提交给对象前后进行一些处理。
    就是说在 真是服务 和 客户端(或者应用代码) 之间的 代理层，可以做多余的处理，比如缓存啊什么的
    即屏蔽直接交互的客户端，只允许通过代理层进行交互

    **代理与其服务对象遵循同一接口， 使得自己和服务对象可以互换**
    可以对服务进行保护，记录日志，管控生命周期等等
    即使服务对象还未准备好或不存在， 代理也可以正常工作。

- 行为模式

  - 观察者模式
    > 事件订阅者、监听者、Event-Subscriber、Listener、Observer

    有两个角色：Subscriber(订阅者) 和 Publisher(发布者)
    一般来说 Subscriber 提供一个 update 方法，这样当 Publisher 开始 notify 的时候，会从 listeners(一般是一个 HashMap，存储 Subscriber 和 Event 的对应关系) 中遍历该 Event 的所有的 Subscriber，并调用其 update 方法

  - 中介者模式

    在各个组件之间建立一个中介者，各个组件直接与中介者交互，而不是直接与其他组件交互
    关于每个组件之间的调用关系，由中介者来决定

    中介者的主要目标是消除一系列系统组件之间的相互依赖。
    这些组件将依赖于同一个中介者对象。 观察者的目标是在对象之间建立动态的单向连接， 使得部分对象可作为其他对象的附属发挥作用。

  - 责任链模式
    > 职责链模式、命令链、CoR、Chain of Command、Chain of Responsibility
    
    模式建议你将这些处理者连成一条链。
    链上的每个处理者都有一个成员变量来保存对于下一处理者的引用。
    除了处理请求外，处理者还负责沿着链传递请求。请求会在链上移动，直至所有处理者都有机会对其进行处理。
    **处理者可以决定不再沿着链传递请求， 这可高效地取消所有后续处理步骤。**
    并且这个请求可以发送给链上任意一个处理者
