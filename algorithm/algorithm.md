### 双向 BFS

因为单 BFS 的递归树太大了
所以双向 BFS 大大减少递归树

### 摩尔投票算法
candidate
count

若 count 为 0，则 candidate = num[i]
否则 count ++ / --

遍历结束之后，如果数组中存在主要元素，则 candidate 即为主要元素，否则 candidate 可能为数组中的任意一个元素。

所以需要二次验证，再次遍历

### 康托展开

快速计算排列第 x 位
双射，所以可逆运算

### 数位 DP

对于「数位 DP」题，都存在：询问 [a, b]（a 和 b 均为正整数，且 a < b）区间内符合条件的数值个数为多少」的一般形式，通常我们需要实现一个查询 [0, x] 有多少合法数值的函数 int dp(int x)，然后应用「容斥原理」求解出 [a, b] 的个数：dp(b) - dp(a - 1)


### 胜者树与败者树

相比堆，减少了比较次数

由于新加入的节点一定是替换了上一轮的胜者，那么对于胜者堆，从新节点到根之间路径节点存的都是上一轮的胜者，这些数据事实上对于本轮比较来说是无用的，但每次还要与兄弟节点比较去更新它。 => 每次一定要访问一次父节点和一次兄弟节点

而败者堆中，对于新更新的节点，它的父节点都是兄弟子堆的胜者，是最有价值、值得比较的数据，每次更新也都可以直接用于下轮比较。 => 每次只需要访问父节点

### PBDS

Policy based data structures in g++

cpp stl 之外的提供的数据结构

有更神奇的自定义等等，比如在树中查询第 x 个元素
